import {
  require_crypto
} from "./chunk-G5OYT7X7.js";
import {
  __commonJS
} from "./chunk-BUSYA2B4.js";

// node_modules/crc-32/crc32.js
var require_crc32 = __commonJS({
  "node_modules/crc-32/crc32.js"(exports) {
    var CRC32;
    (function(factory) {
      if (typeof DO_NOT_EXPORT_CRC === "undefined") {
        if ("object" === typeof exports) {
          factory(exports);
        } else if ("function" === typeof define && define.amd) {
          define(function() {
            var module2 = {};
            factory(module2);
            return module2;
          });
        } else {
          factory(CRC32 = {});
        }
      } else {
        factory(CRC32 = {});
      }
    })(function(CRC322) {
      CRC322.version = "1.2.0";
      function signed_crc_table() {
        var c = 0, table = new Array(256);
        for (var n = 0; n != 256; ++n) {
          c = n;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          table[n] = c;
        }
        return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
      }
      var T = signed_crc_table();
      function crc32_bstr(bstr, seed) {
        var C = seed ^ -1, L = bstr.length - 1;
        for (var i = 0; i < L; ) {
          C = C >>> 8 ^ T[(C ^ bstr.charCodeAt(i++)) & 255];
          C = C >>> 8 ^ T[(C ^ bstr.charCodeAt(i++)) & 255];
        }
        if (i === L) C = C >>> 8 ^ T[(C ^ bstr.charCodeAt(i)) & 255];
        return C ^ -1;
      }
      function crc32_buf(buf, seed) {
        if (buf.length > 1e4) return crc32_buf_8(buf, seed);
        var C = seed ^ -1, L = buf.length - 3;
        for (var i = 0; i < L; ) {
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
        }
        while (i < L + 3) C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
        return C ^ -1;
      }
      function crc32_buf_8(buf, seed) {
        var C = seed ^ -1, L = buf.length - 7;
        for (var i = 0; i < L; ) {
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
        }
        while (i < L + 7) C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
        return C ^ -1;
      }
      function crc32_str(str, seed) {
        var C = seed ^ -1;
        for (var i = 0, L = str.length, c, d; i < L; ) {
          c = str.charCodeAt(i++);
          if (c < 128) {
            C = C >>> 8 ^ T[(C ^ c) & 255];
          } else if (c < 2048) {
            C = C >>> 8 ^ T[(C ^ (192 | c >> 6 & 31)) & 255];
            C = C >>> 8 ^ T[(C ^ (128 | c & 63)) & 255];
          } else if (c >= 55296 && c < 57344) {
            c = (c & 1023) + 64;
            d = str.charCodeAt(i++) & 1023;
            C = C >>> 8 ^ T[(C ^ (240 | c >> 8 & 7)) & 255];
            C = C >>> 8 ^ T[(C ^ (128 | c >> 2 & 63)) & 255];
            C = C >>> 8 ^ T[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
            C = C >>> 8 ^ T[(C ^ (128 | d & 63)) & 255];
          } else {
            C = C >>> 8 ^ T[(C ^ (224 | c >> 12 & 15)) & 255];
            C = C >>> 8 ^ T[(C ^ (128 | c >> 6 & 63)) & 255];
            C = C >>> 8 ^ T[(C ^ (128 | c & 63)) & 255];
          }
        }
        return C ^ -1;
      }
      CRC322.table = T;
      CRC322.bstr = crc32_bstr;
      CRC322.buf = crc32_buf;
      CRC322.str = crc32_str;
    });
  }
});

// node_modules/cuint/lib/uint32.js
var require_uint32 = __commonJS({
  "node_modules/cuint/lib/uint32.js"(exports, module) {
    (function(root) {
      var radixPowerCache = {
        36: UINT32(Math.pow(36, 5)),
        16: UINT32(Math.pow(16, 7)),
        10: UINT32(Math.pow(10, 9)),
        2: UINT32(Math.pow(2, 30))
      };
      var radixCache = {
        36: UINT32(36),
        16: UINT32(16),
        10: UINT32(10),
        2: UINT32(2)
      };
      function UINT32(l, h) {
        if (!(this instanceof UINT32))
          return new UINT32(l, h);
        this._low = 0;
        this._high = 0;
        this.remainder = null;
        if (typeof h == "undefined")
          return fromNumber.call(this, l);
        if (typeof l == "string")
          return fromString.call(this, l, h);
        fromBits.call(this, l, h);
      }
      function fromBits(l, h) {
        this._low = l | 0;
        this._high = h | 0;
        return this;
      }
      UINT32.prototype.fromBits = fromBits;
      function fromNumber(value) {
        this._low = value & 65535;
        this._high = value >>> 16;
        return this;
      }
      UINT32.prototype.fromNumber = fromNumber;
      function fromString(s, radix) {
        var value = parseInt(s, radix || 10);
        this._low = value & 65535;
        this._high = value >>> 16;
        return this;
      }
      UINT32.prototype.fromString = fromString;
      UINT32.prototype.toNumber = function() {
        return this._high * 65536 + this._low;
      };
      UINT32.prototype.toString = function(radix) {
        return this.toNumber().toString(radix || 10);
      };
      UINT32.prototype.add = function(other) {
        var a00 = this._low + other._low;
        var a16 = a00 >>> 16;
        a16 += this._high + other._high;
        this._low = a00 & 65535;
        this._high = a16 & 65535;
        return this;
      };
      UINT32.prototype.subtract = function(other) {
        return this.add(other.clone().negate());
      };
      UINT32.prototype.multiply = function(other) {
        var a16 = this._high;
        var a00 = this._low;
        var b16 = other._high;
        var b00 = other._low;
        var c16, c00;
        c00 = a00 * b00;
        c16 = c00 >>> 16;
        c16 += a16 * b00;
        c16 &= 65535;
        c16 += a00 * b16;
        this._low = c00 & 65535;
        this._high = c16 & 65535;
        return this;
      };
      UINT32.prototype.div = function(other) {
        if (other._low == 0 && other._high == 0) throw Error("division by zero");
        if (other._high == 0 && other._low == 1) {
          this.remainder = new UINT32(0);
          return this;
        }
        if (other.gt(this)) {
          this.remainder = this.clone();
          this._low = 0;
          this._high = 0;
          return this;
        }
        if (this.eq(other)) {
          this.remainder = new UINT32(0);
          this._low = 1;
          this._high = 0;
          return this;
        }
        var _other = other.clone();
        var i = -1;
        while (!this.lt(_other)) {
          _other.shiftLeft(1, true);
          i++;
        }
        this.remainder = this.clone();
        this._low = 0;
        this._high = 0;
        for (; i >= 0; i--) {
          _other.shiftRight(1);
          if (!this.remainder.lt(_other)) {
            this.remainder.subtract(_other);
            if (i >= 16) {
              this._high |= 1 << i - 16;
            } else {
              this._low |= 1 << i;
            }
          }
        }
        return this;
      };
      UINT32.prototype.negate = function() {
        var v = (~this._low & 65535) + 1;
        this._low = v & 65535;
        this._high = ~this._high + (v >>> 16) & 65535;
        return this;
      };
      UINT32.prototype.equals = UINT32.prototype.eq = function(other) {
        return this._low == other._low && this._high == other._high;
      };
      UINT32.prototype.greaterThan = UINT32.prototype.gt = function(other) {
        if (this._high > other._high) return true;
        if (this._high < other._high) return false;
        return this._low > other._low;
      };
      UINT32.prototype.lessThan = UINT32.prototype.lt = function(other) {
        if (this._high < other._high) return true;
        if (this._high > other._high) return false;
        return this._low < other._low;
      };
      UINT32.prototype.or = function(other) {
        this._low |= other._low;
        this._high |= other._high;
        return this;
      };
      UINT32.prototype.and = function(other) {
        this._low &= other._low;
        this._high &= other._high;
        return this;
      };
      UINT32.prototype.not = function() {
        this._low = ~this._low & 65535;
        this._high = ~this._high & 65535;
        return this;
      };
      UINT32.prototype.xor = function(other) {
        this._low ^= other._low;
        this._high ^= other._high;
        return this;
      };
      UINT32.prototype.shiftRight = UINT32.prototype.shiftr = function(n) {
        if (n > 16) {
          this._low = this._high >> n - 16;
          this._high = 0;
        } else if (n == 16) {
          this._low = this._high;
          this._high = 0;
        } else {
          this._low = this._low >> n | this._high << 16 - n & 65535;
          this._high >>= n;
        }
        return this;
      };
      UINT32.prototype.shiftLeft = UINT32.prototype.shiftl = function(n, allowOverflow) {
        if (n > 16) {
          this._high = this._low << n - 16;
          this._low = 0;
          if (!allowOverflow) {
            this._high &= 65535;
          }
        } else if (n == 16) {
          this._high = this._low;
          this._low = 0;
        } else {
          this._high = this._high << n | this._low >> 16 - n;
          this._low = this._low << n & 65535;
          if (!allowOverflow) {
            this._high &= 65535;
          }
        }
        return this;
      };
      UINT32.prototype.rotateLeft = UINT32.prototype.rotl = function(n) {
        var v = this._high << 16 | this._low;
        v = v << n | v >>> 32 - n;
        this._low = v & 65535;
        this._high = v >>> 16;
        return this;
      };
      UINT32.prototype.rotateRight = UINT32.prototype.rotr = function(n) {
        var v = this._high << 16 | this._low;
        v = v >>> n | v << 32 - n;
        this._low = v & 65535;
        this._high = v >>> 16;
        return this;
      };
      UINT32.prototype.clone = function() {
        return new UINT32(this._low, this._high);
      };
      if (typeof define != "undefined" && define.amd) {
        define([], function() {
          return UINT32;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = UINT32;
      } else {
        root["UINT32"] = UINT32;
      }
    })(exports);
  }
});

// node_modules/cuint/lib/uint64.js
var require_uint64 = __commonJS({
  "node_modules/cuint/lib/uint64.js"(exports, module) {
    (function(root) {
      var radixPowerCache = {
        16: UINT64(Math.pow(16, 5)),
        10: UINT64(Math.pow(10, 5)),
        2: UINT64(Math.pow(2, 5))
      };
      var radixCache = {
        16: UINT64(16),
        10: UINT64(10),
        2: UINT64(2)
      };
      function UINT64(a00, a16, a32, a48) {
        if (!(this instanceof UINT64))
          return new UINT64(a00, a16, a32, a48);
        this.remainder = null;
        if (typeof a00 == "string")
          return fromString.call(this, a00, a16);
        if (typeof a16 == "undefined")
          return fromNumber.call(this, a00);
        fromBits.apply(this, arguments);
      }
      function fromBits(a00, a16, a32, a48) {
        if (typeof a32 == "undefined") {
          this._a00 = a00 & 65535;
          this._a16 = a00 >>> 16;
          this._a32 = a16 & 65535;
          this._a48 = a16 >>> 16;
          return this;
        }
        this._a00 = a00 | 0;
        this._a16 = a16 | 0;
        this._a32 = a32 | 0;
        this._a48 = a48 | 0;
        return this;
      }
      UINT64.prototype.fromBits = fromBits;
      function fromNumber(value) {
        this._a00 = value & 65535;
        this._a16 = value >>> 16;
        this._a32 = 0;
        this._a48 = 0;
        return this;
      }
      UINT64.prototype.fromNumber = fromNumber;
      function fromString(s, radix) {
        radix = radix || 10;
        this._a00 = 0;
        this._a16 = 0;
        this._a32 = 0;
        this._a48 = 0;
        var radixUint = radixPowerCache[radix] || new UINT64(Math.pow(radix, 5));
        for (var i = 0, len = s.length; i < len; i += 5) {
          var size = Math.min(5, len - i);
          var value = parseInt(s.slice(i, i + size), radix);
          this.multiply(
            size < 5 ? new UINT64(Math.pow(radix, size)) : radixUint
          ).add(new UINT64(value));
        }
        return this;
      }
      UINT64.prototype.fromString = fromString;
      UINT64.prototype.toNumber = function() {
        return this._a16 * 65536 + this._a00;
      };
      UINT64.prototype.toString = function(radix) {
        radix = radix || 10;
        var radixUint = radixCache[radix] || new UINT64(radix);
        if (!this.gt(radixUint)) return this.toNumber().toString(radix);
        var self = this.clone();
        var res = new Array(64);
        for (var i = 63; i >= 0; i--) {
          self.div(radixUint);
          res[i] = self.remainder.toNumber().toString(radix);
          if (!self.gt(radixUint)) break;
        }
        res[i - 1] = self.toNumber().toString(radix);
        return res.join("");
      };
      UINT64.prototype.add = function(other) {
        var a00 = this._a00 + other._a00;
        var a16 = a00 >>> 16;
        a16 += this._a16 + other._a16;
        var a32 = a16 >>> 16;
        a32 += this._a32 + other._a32;
        var a48 = a32 >>> 16;
        a48 += this._a48 + other._a48;
        this._a00 = a00 & 65535;
        this._a16 = a16 & 65535;
        this._a32 = a32 & 65535;
        this._a48 = a48 & 65535;
        return this;
      };
      UINT64.prototype.subtract = function(other) {
        return this.add(other.clone().negate());
      };
      UINT64.prototype.multiply = function(other) {
        var a00 = this._a00;
        var a16 = this._a16;
        var a32 = this._a32;
        var a48 = this._a48;
        var b00 = other._a00;
        var b16 = other._a16;
        var b32 = other._a32;
        var b48 = other._a48;
        var c00 = a00 * b00;
        var c16 = c00 >>> 16;
        c16 += a00 * b16;
        var c32 = c16 >>> 16;
        c16 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c32 += a00 * b32;
        var c48 = c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c48 += a00 * b48;
        c48 &= 65535;
        c48 += a16 * b32;
        c48 &= 65535;
        c48 += a32 * b16;
        c48 &= 65535;
        c48 += a48 * b00;
        this._a00 = c00 & 65535;
        this._a16 = c16 & 65535;
        this._a32 = c32 & 65535;
        this._a48 = c48 & 65535;
        return this;
      };
      UINT64.prototype.div = function(other) {
        if (other._a16 == 0 && other._a32 == 0 && other._a48 == 0) {
          if (other._a00 == 0) throw Error("division by zero");
          if (other._a00 == 1) {
            this.remainder = new UINT64(0);
            return this;
          }
        }
        if (other.gt(this)) {
          this.remainder = this.clone();
          this._a00 = 0;
          this._a16 = 0;
          this._a32 = 0;
          this._a48 = 0;
          return this;
        }
        if (this.eq(other)) {
          this.remainder = new UINT64(0);
          this._a00 = 1;
          this._a16 = 0;
          this._a32 = 0;
          this._a48 = 0;
          return this;
        }
        var _other = other.clone();
        var i = -1;
        while (!this.lt(_other)) {
          _other.shiftLeft(1, true);
          i++;
        }
        this.remainder = this.clone();
        this._a00 = 0;
        this._a16 = 0;
        this._a32 = 0;
        this._a48 = 0;
        for (; i >= 0; i--) {
          _other.shiftRight(1);
          if (!this.remainder.lt(_other)) {
            this.remainder.subtract(_other);
            if (i >= 48) {
              this._a48 |= 1 << i - 48;
            } else if (i >= 32) {
              this._a32 |= 1 << i - 32;
            } else if (i >= 16) {
              this._a16 |= 1 << i - 16;
            } else {
              this._a00 |= 1 << i;
            }
          }
        }
        return this;
      };
      UINT64.prototype.negate = function() {
        var v = (~this._a00 & 65535) + 1;
        this._a00 = v & 65535;
        v = (~this._a16 & 65535) + (v >>> 16);
        this._a16 = v & 65535;
        v = (~this._a32 & 65535) + (v >>> 16);
        this._a32 = v & 65535;
        this._a48 = ~this._a48 + (v >>> 16) & 65535;
        return this;
      };
      UINT64.prototype.equals = UINT64.prototype.eq = function(other) {
        return this._a48 == other._a48 && this._a00 == other._a00 && this._a32 == other._a32 && this._a16 == other._a16;
      };
      UINT64.prototype.greaterThan = UINT64.prototype.gt = function(other) {
        if (this._a48 > other._a48) return true;
        if (this._a48 < other._a48) return false;
        if (this._a32 > other._a32) return true;
        if (this._a32 < other._a32) return false;
        if (this._a16 > other._a16) return true;
        if (this._a16 < other._a16) return false;
        return this._a00 > other._a00;
      };
      UINT64.prototype.lessThan = UINT64.prototype.lt = function(other) {
        if (this._a48 < other._a48) return true;
        if (this._a48 > other._a48) return false;
        if (this._a32 < other._a32) return true;
        if (this._a32 > other._a32) return false;
        if (this._a16 < other._a16) return true;
        if (this._a16 > other._a16) return false;
        return this._a00 < other._a00;
      };
      UINT64.prototype.or = function(other) {
        this._a00 |= other._a00;
        this._a16 |= other._a16;
        this._a32 |= other._a32;
        this._a48 |= other._a48;
        return this;
      };
      UINT64.prototype.and = function(other) {
        this._a00 &= other._a00;
        this._a16 &= other._a16;
        this._a32 &= other._a32;
        this._a48 &= other._a48;
        return this;
      };
      UINT64.prototype.xor = function(other) {
        this._a00 ^= other._a00;
        this._a16 ^= other._a16;
        this._a32 ^= other._a32;
        this._a48 ^= other._a48;
        return this;
      };
      UINT64.prototype.not = function() {
        this._a00 = ~this._a00 & 65535;
        this._a16 = ~this._a16 & 65535;
        this._a32 = ~this._a32 & 65535;
        this._a48 = ~this._a48 & 65535;
        return this;
      };
      UINT64.prototype.shiftRight = UINT64.prototype.shiftr = function(n) {
        n %= 64;
        if (n >= 48) {
          this._a00 = this._a48 >> n - 48;
          this._a16 = 0;
          this._a32 = 0;
          this._a48 = 0;
        } else if (n >= 32) {
          n -= 32;
          this._a00 = (this._a32 >> n | this._a48 << 16 - n) & 65535;
          this._a16 = this._a48 >> n & 65535;
          this._a32 = 0;
          this._a48 = 0;
        } else if (n >= 16) {
          n -= 16;
          this._a00 = (this._a16 >> n | this._a32 << 16 - n) & 65535;
          this._a16 = (this._a32 >> n | this._a48 << 16 - n) & 65535;
          this._a32 = this._a48 >> n & 65535;
          this._a48 = 0;
        } else {
          this._a00 = (this._a00 >> n | this._a16 << 16 - n) & 65535;
          this._a16 = (this._a16 >> n | this._a32 << 16 - n) & 65535;
          this._a32 = (this._a32 >> n | this._a48 << 16 - n) & 65535;
          this._a48 = this._a48 >> n & 65535;
        }
        return this;
      };
      UINT64.prototype.shiftLeft = UINT64.prototype.shiftl = function(n, allowOverflow) {
        n %= 64;
        if (n >= 48) {
          this._a48 = this._a00 << n - 48;
          this._a32 = 0;
          this._a16 = 0;
          this._a00 = 0;
        } else if (n >= 32) {
          n -= 32;
          this._a48 = this._a16 << n | this._a00 >> 16 - n;
          this._a32 = this._a00 << n & 65535;
          this._a16 = 0;
          this._a00 = 0;
        } else if (n >= 16) {
          n -= 16;
          this._a48 = this._a32 << n | this._a16 >> 16 - n;
          this._a32 = (this._a16 << n | this._a00 >> 16 - n) & 65535;
          this._a16 = this._a00 << n & 65535;
          this._a00 = 0;
        } else {
          this._a48 = this._a48 << n | this._a32 >> 16 - n;
          this._a32 = (this._a32 << n | this._a16 >> 16 - n) & 65535;
          this._a16 = (this._a16 << n | this._a00 >> 16 - n) & 65535;
          this._a00 = this._a00 << n & 65535;
        }
        if (!allowOverflow) {
          this._a48 &= 65535;
        }
        return this;
      };
      UINT64.prototype.rotateLeft = UINT64.prototype.rotl = function(n) {
        n %= 64;
        if (n == 0) return this;
        if (n >= 32) {
          var v = this._a00;
          this._a00 = this._a32;
          this._a32 = v;
          v = this._a48;
          this._a48 = this._a16;
          this._a16 = v;
          if (n == 32) return this;
          n -= 32;
        }
        var high = this._a48 << 16 | this._a32;
        var low = this._a16 << 16 | this._a00;
        var _high = high << n | low >>> 32 - n;
        var _low = low << n | high >>> 32 - n;
        this._a00 = _low & 65535;
        this._a16 = _low >>> 16;
        this._a32 = _high & 65535;
        this._a48 = _high >>> 16;
        return this;
      };
      UINT64.prototype.rotateRight = UINT64.prototype.rotr = function(n) {
        n %= 64;
        if (n == 0) return this;
        if (n >= 32) {
          var v = this._a00;
          this._a00 = this._a32;
          this._a32 = v;
          v = this._a48;
          this._a48 = this._a16;
          this._a16 = v;
          if (n == 32) return this;
          n -= 32;
        }
        var high = this._a48 << 16 | this._a32;
        var low = this._a16 << 16 | this._a00;
        var _high = high >>> n | low << 32 - n;
        var _low = low >>> n | high << 32 - n;
        this._a00 = _low & 65535;
        this._a16 = _low >>> 16;
        this._a32 = _high & 65535;
        this._a48 = _high >>> 16;
        return this;
      };
      UINT64.prototype.clone = function() {
        return new UINT64(this._a00, this._a16, this._a32, this._a48);
      };
      if (typeof define != "undefined" && define.amd) {
        define([], function() {
          return UINT64;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = UINT64;
      } else {
        root["UINT64"] = UINT64;
      }
    })(exports);
  }
});

// node_modules/cuint/index.js
var require_cuint = __commonJS({
  "node_modules/cuint/index.js"(exports) {
    exports.UINT32 = require_uint32();
    exports.UINT64 = require_uint64();
  }
});

// node_modules/agora-access-token/src/AccessToken.js
var require_AccessToken = __commonJS({
  "node_modules/agora-access-token/src/AccessToken.js"(exports, module) {
    var crypto = require_crypto();
    var crc32 = require_crc32();
    var UINT32 = require_cuint().UINT32;
    var version = "006";
    var randomInt = Math.floor(Math.random() * 4294967295);
    var VERSION_LENGTH = 3;
    var APP_ID_LENGTH = 32;
    var AccessToken = function(appID, appCertificate, channelName, uid) {
      let token = this;
      this.appID = appID;
      this.appCertificate = appCertificate;
      this.channelName = channelName;
      this.messages = {};
      this.salt = randomInt;
      this.ts = Math.floor(/* @__PURE__ */ new Date() / 1e3) + 24 * 3600;
      if (uid === 0) {
        this.uid = "";
      } else {
        this.uid = `${uid}`;
      }
      this.build = function() {
        var m = Message({
          salt: token.salt,
          ts: token.ts,
          messages: token.messages
        }).pack();
        var toSign = Buffer.concat(
          [
            Buffer.from(token.appID, "utf8"),
            Buffer.from(token.channelName, "utf8"),
            Buffer.from(token.uid, "utf8"),
            m
          ]
        );
        var signature = encodeHMac(token.appCertificate, toSign);
        var crc_channel = UINT32(crc32.str(token.channelName)).and(UINT32(4294967295)).toNumber();
        var crc_uid = UINT32(crc32.str(token.uid)).and(UINT32(4294967295)).toNumber();
        var content = AccessTokenContent({
          signature,
          crc_channel,
          crc_uid,
          m
        }).pack();
        return version + token.appID + content.toString("base64");
      };
      this.addPriviledge = function(priviledge, expireTimestamp) {
        token.messages[priviledge] = expireTimestamp;
      };
      this.fromString = function(originToken) {
        try {
          originVersion = originToken.substr(0, VERSION_LENGTH);
          if (originVersion != version) {
            return false;
          }
          var originAppID = originToken.substr(VERSION_LENGTH, VERSION_LENGTH + APP_ID_LENGTH);
          var originContent = originToken.substr(VERSION_LENGTH + APP_ID_LENGTH);
          var originContentDecodedBuf = Buffer.from(originContent, "base64");
          var content = unPackContent(originContentDecodedBuf);
          this.signature = content.signature;
          this.crc_channel_name = content.crc_channel_name;
          this.crc_uid = content.crc_uid;
          this.m = content.m;
          var msgs = unPackMessages(this.m);
          this.salt = msgs.salt;
          this.ts = msgs.ts;
          this.messages = msgs.messages;
        } catch (err) {
          console.log(err);
          return false;
        }
        return true;
      };
    };
    module.exports.version = version;
    module.exports.AccessToken = AccessToken;
    module.exports.priviledges = {
      kJoinChannel: 1,
      kPublishAudioStream: 2,
      kPublishVideoStream: 3,
      kPublishDataStream: 4,
      kPublishAudiocdn: 5,
      kPublishVideoCdn: 6,
      kRequestPublishAudioStream: 7,
      kRequestPublishVideoStream: 8,
      kRequestPublishDataStream: 9,
      kInvitePublishAudioStream: 10,
      kInvitePublishVideoStream: 11,
      kInvitePublishDataStream: 12,
      kAdministrateChannel: 101,
      kRtmLogin: 1e3
    };
    var encodeHMac = function(key, message) {
      return crypto.createHmac("sha256", key).update(message).digest();
    };
    var ByteBuf = function() {
      var that = {
        buffer: Buffer.alloc(1024),
        position: 0
      };
      that.buffer.fill(0);
      that.pack = function() {
        var out = Buffer.alloc(that.position);
        that.buffer.copy(out, 0, 0, out.length);
        return out;
      };
      that.putUint16 = function(v) {
        that.buffer.writeUInt16LE(v, that.position);
        that.position += 2;
        return that;
      };
      that.putUint32 = function(v) {
        that.buffer.writeUInt32LE(v, that.position);
        that.position += 4;
        return that;
      };
      that.putBytes = function(bytes) {
        that.putUint16(bytes.length);
        bytes.copy(that.buffer, that.position);
        that.position += bytes.length;
        return that;
      };
      that.putString = function(str) {
        return that.putBytes(Buffer.from(str));
      };
      that.putTreeMap = function(map) {
        if (!map) {
          that.putUint16(0);
          return that;
        }
        that.putUint16(Object.keys(map).length);
        for (var key in map) {
          that.putUint16(key);
          that.putString(map[key]);
        }
        return that;
      };
      that.putTreeMapUInt32 = function(map) {
        if (!map) {
          that.putUint16(0);
          return that;
        }
        that.putUint16(Object.keys(map).length);
        for (var key in map) {
          that.putUint16(key);
          that.putUint32(map[key]);
        }
        return that;
      };
      return that;
    };
    var ReadByteBuf = function(bytes) {
      var that = {
        buffer: bytes,
        position: 0
      };
      that.getUint16 = function() {
        var ret = that.buffer.readUInt16LE(that.position);
        that.position += 2;
        return ret;
      };
      that.getUint32 = function() {
        var ret = that.buffer.readUInt32LE(that.position);
        that.position += 4;
        return ret;
      };
      that.getString = function() {
        var len = that.getUint16();
        var out = Buffer.alloc(len);
        that.buffer.copy(out, 0, that.position, that.position + len);
        that.position += len;
        return out;
      };
      that.getTreeMapUInt32 = function() {
        var map = {};
        var len = that.getUint16();
        for (var i = 0; i < len; i++) {
          var key = that.getUint16();
          var value = that.getUint32();
          map[key] = value;
        }
        return map;
      };
      return that;
    };
    var AccessTokenContent = function(options) {
      options.pack = function() {
        var out = new ByteBuf();
        return out.putString(options.signature).putUint32(options.crc_channel).putUint32(options.crc_uid).putString(options.m).pack();
      };
      return options;
    };
    var Message = function(options) {
      options.pack = function() {
        var out = new ByteBuf();
        var val = out.putUint32(options.salt).putUint32(options.ts).putTreeMapUInt32(options.messages).pack();
        return val;
      };
      return options;
    };
    var unPackContent = function(bytes) {
      var readbuf = new ReadByteBuf(bytes);
      return AccessTokenContent({
        signature: readbuf.getString(),
        crc_channel_name: readbuf.getUint32(),
        crc_uid: readbuf.getUint32(),
        m: readbuf.getString()
      });
    };
    var unPackMessages = function(bytes) {
      var readbuf = new ReadByteBuf(bytes);
      return Message({
        salt: readbuf.getUint32(),
        ts: readbuf.getUint32(),
        messages: readbuf.getTreeMapUInt32()
      });
    };
  }
});

// node_modules/agora-access-token/src/RtcTokenBuilder.js
var require_RtcTokenBuilder = __commonJS({
  "node_modules/agora-access-token/src/RtcTokenBuilder.js"(exports, module) {
    var AccessToken = require_AccessToken().AccessToken;
    var Priviledges = require_AccessToken().priviledges;
    var Role = {
      // DEPRECATED. Role::ATTENDEE has the same privileges as Role.PUBLISHER.
      ATTENDEE: 0,
      // RECOMMENDED. Use this role for a voice/video call or a live broadcast, if your scenario does not require authentication for [Hosting-in](https://docs.agora.io/en/Agora%20Platform/terms?platform=All%20Platforms#hosting-in).
      PUBLISHER: 1,
      /* Only use this role if your scenario require authentication for [Hosting-in](https://docs.agora.io/en/Agora%20Platform/terms?platform=All%20Platforms#hosting-in).
       * @note In order for this role to take effect, please contact our support team to enable authentication for Hosting-in for you. Otherwise, Role.SUBSCRIBER still has the same privileges as Role.PUBLISHER.
       */
      SUBSCRIBER: 2,
      // DEPRECATED. Role.ADMIN has the same privileges as Role.PUBLISHER.
      ADMIN: 101
    };
    var RtcTokenBuilder = class {
      /**
       * Builds an RTC token using an Integer uid.
       * @param {*} appID  The App ID issued to you by Agora.
       * @param {*} appCertificate Certificate of the application that you registered in the Agora Dashboard.
       * @param {*} channelName The unique channel name for the AgoraRTC session in the string format. The string length must be less than 64 bytes. Supported character scopes are:
       * - The 26 lowercase English letters: a to z.
       * - The 26 uppercase English letters: A to Z.
       * - The 10 digits: 0 to 9.
       * - The space.
       * - "!", "#", "$", "%", "&", "(", ")", "+", "-", ":", ";", "<", "=", ".", ">", "?", "@", "[", "]", "^", "_", " {", "}", "|", "~", ",".
       * @param {*} uid User ID. A 32-bit unsigned integer with a value ranging from 1 to (2^32-1).
       * @param {*} role See #userRole.
       * - Role.PUBLISHER; RECOMMENDED. Use this role for a voice/video call or a live broadcast.
       * - Role.SUBSCRIBER: ONLY use this role if your live-broadcast scenario requires authentication for [Hosting-in](https://docs.agora.io/en/Agora%20Platform/terms?platform=All%20Platforms#hosting-in). In order for this role to take effect, please contact our support team to enable authentication for Hosting-in for you. Otherwise, Role_Subscriber still has the same privileges as Role_Publisher.
       * @param {*} privilegeExpiredTs  represented by the number of seconds elapsed since 1/1/1970. If, for example, you want to access the Agora Service within 10 minutes after the token is generated, set expireTimestamp as the current timestamp + 600 (seconds).
       * @return The new Token.
       */
      static buildTokenWithUid(appID, appCertificate, channelName, uid, role, privilegeExpiredTs) {
        return this.buildTokenWithAccount(appID, appCertificate, channelName, uid, role, privilegeExpiredTs);
      }
      /**
       * Builds an RTC token using an Integer uid.
       * @param {*} appID  The App ID issued to you by Agora.
       * @param {*} appCertificate Certificate of the application that you registered in the Agora Dashboard.
       * @param {*} channelName The unique channel name for the AgoraRTC session in the string format. The string length must be less than 64 bytes. Supported character scopes are:
       * - The 26 lowercase English letters: a to z.
       * - The 26 uppercase English letters: A to Z.
       * - The 10 digits: 0 to 9.
       * - The space.
       * - "!", "#", "$", "%", "&", "(", ")", "+", "-", ":", ";", "<", "=", ".", ">", "?", "@", "[", "]", "^", "_", " {", "}", "|", "~", ",".
       * @param {*} account The user account.
       * @param {*} role See #userRole.
       * - Role.PUBLISHER; RECOMMENDED. Use this role for a voice/video call or a live broadcast.
       * - Role.SUBSCRIBER: ONLY use this role if your live-broadcast scenario requires authentication for [Hosting-in](https://docs.agora.io/en/Agora%20Platform/terms?platform=All%20Platforms#hosting-in). In order for this role to take effect, please contact our support team to enable authentication for Hosting-in for you. Otherwise, Role_Subscriber still has the same privileges as Role_Publisher.
       * @param {*} privilegeExpiredTs  represented by the number of seconds elapsed since 1/1/1970. If, for example, you want to access the Agora Service within 10 minutes after the token is generated, set expireTimestamp as the current timestamp + 600 (seconds).
       * @return The new Token.
       */
      static buildTokenWithAccount(appID, appCertificate, channelName, account, role, privilegeExpiredTs) {
        this.key = new AccessToken(appID, appCertificate, channelName, account);
        this.key.addPriviledge(Priviledges.kJoinChannel, privilegeExpiredTs);
        if (role == Role.ATTENDEE || role == Role.PUBLISHER || role == Role.ADMIN) {
          this.key.addPriviledge(Priviledges.kPublishAudioStream, privilegeExpiredTs);
          this.key.addPriviledge(Priviledges.kPublishVideoStream, privilegeExpiredTs);
          this.key.addPriviledge(Priviledges.kPublishDataStream, privilegeExpiredTs);
        }
        return this.key.build();
      }
    };
    module.exports.RtcTokenBuilder = RtcTokenBuilder;
    module.exports.Role = Role;
  }
});

// node_modules/agora-access-token/src/RtmTokenBuilder.js
var require_RtmTokenBuilder = __commonJS({
  "node_modules/agora-access-token/src/RtmTokenBuilder.js"(exports, module) {
    var AccessToken = require_AccessToken().AccessToken;
    var Priviledges = require_AccessToken().priviledges;
    var Role = {
      Rtm_User: 1
    };
    var RtmTokenBuilder = class {
      /**
       * @param {*} appID: The App ID issued to you by Agora. Apply for a new App ID from 
       *       Agora Dashboard if it is missing from your kit. See Get an App ID.
       * @param {*} appCertificate:	Certificate of the application that you registered in 
       *                 the Agora Dashboard. See Get an App Certificate.
       * @param {*} account: The user account. 
       * @param {*} role : Role_Publisher = 1: A broadcaster (host) in a live-broadcast profile.
       *      Role_Subscriber = 2: (Default) A audience in a live-broadcast profile.
       * @param {*} privilegeExpiredTs : represented by the number of seconds elapsed since 
       *                   1/1/1970. If, for example, you want to access the
       *                   Agora Service within 10 minutes after the token is 
       *                   generated, set expireTimestamp as the current 
       * @return token
       */
      static buildToken(appID, appCertificate, account, role, privilegeExpiredTs) {
        const key = new AccessToken(appID, appCertificate, account, "");
        key.addPriviledge(Priviledges.kRtmLogin, privilegeExpiredTs);
        return key.build();
      }
    };
    module.exports.RtmTokenBuilder = RtmTokenBuilder;
    module.exports.Role = Role;
  }
});

// node_modules/agora-access-token/index.js
var require_agora_access_token = __commonJS({
  "node_modules/agora-access-token/index.js"(exports, module) {
    module.exports = {
      RtcTokenBuilder: require_RtcTokenBuilder().RtcTokenBuilder,
      RtcRole: require_RtcTokenBuilder().Role,
      RtmTokenBuilder: require_RtmTokenBuilder().RtmTokenBuilder,
      RtmRole: require_RtmTokenBuilder().Role
    };
  }
});
export default require_agora_access_token();
//# sourceMappingURL=agora-access-token.js.map
